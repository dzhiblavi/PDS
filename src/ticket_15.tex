\section{Локально-стабильные предикаты: согласованные интервалы, барьерная 
синхронизация (3 алгоритма). Применение для определения взаимной блокировки 
(deadlock).}

\begin{definition}
    Пара срезов $F, G \subseteq E$ называется \textit{интервалом} $[F, G]$,
    если $F \subseteq G$.
\end{definition}

\begin{definition}
    Интервал $[F, G]$ называется согласованным, если
    \[
        \forall e \in E, f \in F~ e \to f \Lra e \in G
    .\]
\end{definition}

\begin{remark}
    Интервал $[G, G]$ согласован тогда и только тогда, когда $G$ -- согласованный
    срез.
\end{remark}

\begin{theorem}
    Интервал $[F, G]$ согласован тогда и только тогда, когда существует согласванный
    срез $H$ такой, что $F \subseteq H \subseteq G$.
\end{theorem}

\begin{definition}
    Интервал $[F, G]$ называется \textit{барьерно-синхронизированным}, если
    \[
        \forall f \in F, g \in E \setminus G~ f \to g
    .\]
\end{definition}

\begin{theorem}
    Любой барьерно-синхронизированный интервал согласован.
\end{theorem}

\begin{algorithm}(Алгоритмы построения барьерной синхронизации)
    \enewline
    \begin{itemize}
        \item Построение через координатора. Каждый процесс посылает
            координатору сообщение. Когда координатор получил сообщение
            от \textit{всех}, он посылает всем сообщение. Срезы для интервала:
            по посылке сообщений процессами и по приему сообщений от координатора.
        \item Посылка каждый каждому.
        \item Посылка токена два раза по кругу.
    \end{itemize}
\end{algorithm}

\begin{definition}
    \textit{Локально-стабильным} называется стабильный предикат, определяемый
    группой процессов с неизменным состоянием.
\end{definition}

\begin{example}
    Взаимная блокировка -- пример локально-стабильного предиката. Для проверки
    такого предиката необходим согласованный срез. Для этого воспользуемся барьерной
    синхронизацией $[F, G]$. Запомним состояние системы на срезе $F$ (например, это
    может сделать координатор, если он используется). После этого каждый
    процесс будет помнить, менялось ли у него состояние (относительно блокировки).
    Если на момент $G$ состояние у процессов не менялось и на момент $F$ была
    зафиксирована взаимная блокировка, то она в действительности есть.
\end{example}

